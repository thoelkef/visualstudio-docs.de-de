---
title: C26418 | Microsoft-Dokumentation
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26418
helpviewer_keywords:
- C26418
ms.assetid: d2c84a40-8a5d-4018-92c2-6498cdd9b541
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ccdd2170d083ca73f833667974353372c6f89545
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011376"
---
# <a name="c26418-no_value_or_const_ref_shared_ptr"></a>C26418 NO_VALUE_OR_CONST_REF_SHARED_PTR
"Der Parameter für freigegebene Zeiger wird nicht kopiert oder verschoben. Verwenden Sie stattdessen t * oder t &. "

Grundlegende Richtlinien: R. 36: Verwenden Sie ein Konstanten shared_ptr\<widget > & Parameter, um auszudrücken, dass es möglicherweise einen Verweis Zähler für das Objekt beibehält. **C++**

Wenn der Parameter für den freigegebenen Zeiger als Wert oder Verweis an ein konstantes Objekt übergeben wird, wird erwartet, dass die Funktion die Lebensdauer der Zielobjekte übernimmt, ohne dass sich dies auf den Aufrufer auswirkt. Der Code muss den freigegebenen Zeiger Parameter entweder kopieren oder in ein anderes frei gegebenes Zeiger Objekt verschieben oder ihn durch Aufrufen von Funktionen, die freigegebene Zeiger akzeptieren, an anderen Code weitergeben. Wenn dies nicht der Fall ist, ist möglicherweise ein einfacher Zeiger oder Verweis möglich.

## <a name="remarks"></a>Hinweise
- Diese Überprüfung erkennt Std:: shared_pointer und benutzerdefinierte Typen, die sich wahrscheinlich wie freigegebene Zeiger Verhalten. Die folgenden Merkmale werden bei benutzerdefinierten freigegebenen Zeigern erwartet:
- überladene Dereferenzierungsoperatoren oder Element Zugriffs Operatoren (öffentlich und nicht gelöscht);
- Kopierkonstruktor oder Kopier Zuweisungs Operator (öffentlich und nicht gelöscht);
- öffentlicher Dekonstruktor, der weder gelöscht noch standardmäßig ausfällt. Leere dektoren werden immer noch als Benutzer definiert gezählt.

## <a name="example"></a>Beispiel
unnötige Schnittstellen Komplikation

```cpp
template<class T>
std::string to_string(const std::shared_ptr<T> &e) // C26418, also C26415 SMART_PTR_NOT_NEEDED
{
    return !e ? null_string : e->to_string();
}
```

## <a name="example"></a>Beispiel
unnötige Schnittstellen Komplikation-vereinfacht

```cpp
template<class T>
std::string to_string(const T *e)
{
    return !e ? null_string : e->to_string();
}
```
