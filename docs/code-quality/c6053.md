---
title: C6053
ms.date: 11/04/2016
ms.prod: visual-studio-dev15
ms.topic: reference
f1_keywords:
- C6053
helpviewer_keywords:
- C6053
ms.assetid: 8e25566a-e3b9-470a-820d-64221a877c53
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 9f4012e4bc7e5dfc536c448a238151e096ae9038
ms.sourcegitcommit: 37fb7075b0a65d2add3b137a5230767aa3266c74
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 01/02/2019
ms.locfileid: "53904113"
---
# <a name="c6053"></a>C6053
Warnung C6053: Aufruf von \<Funktion > darf nicht 0 (null)-beenden Zeichenfolge \<Variable >

 Diese Warnung gibt an, dass die angegebene Funktion so, dass die resultierende Zeichenfolge nicht 0 (null) endende aufgerufen wurde. Dieser Fehler kann es sich um einen ausnutzbaren Pufferüberlauf oder einen Absturz verursachen. Diese Warnung wird auch generiert, wenn eine mit Anmerkung versehenen Funktion erwartet, dass eine mit null endende Zeichenfolge übergeben wird eine Zeichenfolge, die nicht null ist beendet.

 Die meisten Standardbibliothek für C und Win32-Zeichenfolge, die Funktionen zum Behandeln erfordern, und 0 (null) endende Zeichenfolgen erzeugen. Einige counted String-Funktionen (einschließlich `strncpy`, `wcsncpy`, `_mbsncpy`, `_snprintf`, und `snwprintf`) erzeugen nicht 0 (null) endende Zeichenfolgen, wenn sie genau die Puffer zu füllen. In diesem Fall geht ein nachfolgender Aufruf von einem String-Funktion, die eine NULL-terminierte Zeichenfolge erwartet nach dem Ende des Puffers, die nach der 0 (null). Die Anwendung sollte sicherstellen, dass die Zeichenfolge mit null endet. Im Allgemeinen sollten Sie eine Länge an die "gezählt Zeichenfolge"-Funktion eine kleiner als die Größe des Puffers übergeben und dann explizit 0 (null), auf das letzte Zeichen im Puffer zuweisen.

## <a name="example"></a>Beispiel
 Im folgenden Beispielcode wird diese Warnung generiert:

```cpp

#include <string.h>
#define MAX 15

size_t f( )
{
  char szDest[MAX];
  char *szSource="Hello, World!";

  strncpy(szDest, szSource, MAX);
  return strlen(szDest); // possible crash here
}
```

## <a name="example"></a>Beispiel
 Um diese Warnung zu korrigieren, beenden Sie 0 (null) die Zeichenfolge wie im folgenden Beispielcode gezeigt:

```cpp

#include <string.h>
#define MAX 15

size_t f( )
{
  char szDest[MAX];
  char *szSource="Hello, World!";

  strncpy(szDest, szSource, MAX-1);
  szDest[MAX-1]=0;
  return strlen(szDest);
}
```

## <a name="example"></a>Beispiel
 Der folgende Code korrigiert diese Warnung mit sicheren zeichenfolgenbearbeitung `strncpy_s` Funktion:

```cpp

#include <string.h>
#define MAX 15

size_t f( )
{
  char szDest[MAX];
  char *szSource= "Hello, World!";

  strncpy_s(szDest, sizeof(szDest), szSource, strlen(szSource));
  return strlen(szDest);
}
```

 Beachten Sie, dass diese Warnung manchmal für bestimmte Ausdrücke, die garantiert sicher in der Praxis gemeldet wird. Aufgrund der Häufigkeit und die möglichen Folgen dieses Fehlers wird vom Analysetool gewichtet, und ermitteln potenzielle Probleme, anstatt die typischen Bias informationsrauschen zu reduzieren.

## <a name="see-also"></a>Siehe auch

- [Verwenden von SAL-Anmerkungen zum Reduzieren von Codefehlern](using-sal-annotations-to-reduce-c-cpp-code-defects.md)
- [strncpy_s, _strncpy_s_l, wcsncpy_s, _wcsncpy_s_l, _mbsncpy_s, _mbsncpy_s_l](/cpp/c-runtime-library/reference/strncpy-s-strncpy-s-l-wcsncpy-s-wcsncpy-s-l-mbsncpy-s-mbsncpy-s-l)