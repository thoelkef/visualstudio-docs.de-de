---
title: Verwendungswarnungen
ms.date: 11/04/2016
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- vs.codeanalysis.usagerules
helpviewer_keywords:
- warnings, usage
- managed code analysis warnings, usage warnings
- usage warnings
ms.assetid: fe7dc2a3-289d-4bf7-a1e4-0947a81287c4
author: gewarren
ms.author: gewarren
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 9e83421cefd78582c05f20d1efc936ba60c1fc47
ms.sourcegitcommit: e13e61ddea6032a8282abe16131d9e136a927984
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/26/2018
ms.locfileid: "31927058"
---
# <a name="usage-warnings"></a>Verwendungswarnungen
Verwendungswarnungen unterstützen die richtigen Verwendung von .NET Framework.

## <a name="in-this-section"></a>In diesem Abschnitt

|Regel|Beschreibung|
|----------|-----------------|
|[CA1801: Nicht verwendete Parameter überprüfen](../code-quality/ca1801-review-unused-parameters.md)|Eine Methodensignatur enthält einen Parameter, der nicht im Methodentext verwendet wird.|
|[CA1806: Methodenergebnisse nicht ignorieren](../code-quality/ca1806-do-not-ignore-method-results.md)|Ein neues Objekt wird erstellt, aber nie verwendet, oder eine Methode wird aufgerufen, die eine neue Zeichenfolge erstellt und zurückgibt, die nie verwendet wird, oder eine COM-Methode oder P/Invoke-Methode gibt ein HRESULT oder einen Fehlercode zurück, das oder der nie verwendet wird.|
|[CA1816: GC.SuppressFinalize korrekt aufrufen](../code-quality/ca1816-call-gc-suppressfinalize-correctly.md)|Eine Methode, die eine Implementierung von Dispose bildet, ruft nicht GC. SuppressFinalize; oder eine Methode, die keine Implementierung von Dispose bildet, ruft GC. SuppressFinalize; oder eine Methode aufruft, GC. SuppressFinalize auf und übergibt ein anderes Element als dieses (Me in Visual Basic).|
|[CA2200: Erneut ausführen, um Stapeldetails beizubehalten](../code-quality/ca2200-rethrow-to-preserve-stack-details.md)|Eine Ausnahme wird erneut ausgelöst, und die Ausnahme wird in der Throw-Anweisung explizit angegeben. Wenn eine Ausnahme durch Angeben der Ausnahme in der Throw-Anweisung erneut ausgelöst wird, ist die Liste der Methodenaufrufe zwischen der ursprünglichen Methode, die die Ausnahme ausgelöst hat und die aktuelle Methode verloren gehen.|
|[CA2201: Keine reservierten Ausnahmetypen auslösen](../code-quality/ca2201-do-not-raise-reserved-exception-types.md)|Dies ist der ursprüngliche Fehler schwer zu erkennen und zu debuggen.|
|[CA2202: Objekte nicht mehrmals verwerfen](../code-quality/ca2202-do-not-dispose-objects-multiple-times.md)|Eine Methodenimplementierung enthält Codepfade, die für dasselbe Objekt mehrere Aufrufe von System.IDisposable.Dispose oder einer Entsprechung von Dispose (z. B. einer Close()-Methode für bestimmte Typen) verursachen können.|
|[CA2204: Literale sollten eine korrekte Rechtschreibung aufweisen](../code-quality/ca2204-literals-should-be-spelled-correctly.md)|Ein Zeichenfolgenliteral in einem Methodentext enthält mindestens ein Wort, das von der Rechtschreibprüfung aus der Microsoft-Bibliothek nicht erkannt wird.|
|[CA2205: Verwaltete Entsprechungen der Win32-API verwenden](../code-quality/ca2205-use-managed-equivalents-of-win32-api.md)|Ein Plattformaufruf Methode definiert ist, und eine Methode mit entsprechender Funktionalität, die in der .NET Framework-Klassenbibliothek vorhanden ist.|
|[CA2207: Statische Felder für Werttyp inline initialisieren](../code-quality/ca2207-initialize-value-type-static-fields-inline.md)|Ein Werttyp deklariert einen expliziten statischen Konstruktor. Um einen Verstoß gegen diese Regel zu beheben, initialisieren Sie alle statischen Daten nach deren Deklaration und entfernen den statischen Konstruktor.|
|[CA2208: Argumentausnahmen korrekt instanziieren](../code-quality/ca2208-instantiate-argument-exceptions-correctly.md)|Der (parameterlose) Standardkonstruktor eines Ausnahmetyps wird aufgerufen, der ArgumentException ist oder davon abgeleitet wird, oder ein falsches Zeichenfolgenargument wird an einen parametrisierten Konstruktor eines Ausnahmetyps übergeben, der ArgumentException ist oder davon abgeleitet wird.|
|[CA2211: Nicht konstante Felder sollten nicht sichtbar sein](../code-quality/ca2211-non-constant-fields-should-not-be-visible.md)|Statische Felder, die weder konstant noch schreibgeschützt sind, sind nicht threadsicher. Zugriff auf ein solches Feld muss sorgfältig kontrolliert werden und erfordert fortgeschrittene Programmiertechniken zur Synchronisierung des Zugriffs auf das Klassenobjekt.|
|[CA2212: ServicedComponents nicht mit WebMethod markieren](../code-quality/ca2212-do-not-mark-serviced-components-with-webmethod.md)|Eine Methode in einem Typ, der von System.EnterpriseServices.ServicedComponent erbt, wird mit System.Web.Services.WebMethodAttribute markiert. Da das Verhalten von WebMethodAttribute und einer ServicedComponent-Methode sowie deren Anforderungen an den Kontext sowie den Transaktionsablauf zu Konflikten führen, ist das Verhalten der Methode in bestimmten Szenarien fehlerhaft.|
|[CA2213: Verwerfbare Felder verwerfen](../code-quality/ca2213-disposable-fields-should-be-disposed.md)|Ein Typ, der System.IDisposable implementiert, deklariert Felder von Typen, die ebenfalls IDisposable implementieren. Die Dispose-Methode des Felds wird nicht von der Dispose-Methode des deklarierenden Typs aufgerufen.|
|[CA2214: Überschreibbare Methoden in Konstruktoren nicht aufrufen](../code-quality/ca2214-do-not-call-overridable-methods-in-constructors.md)|Wenn ein Konstruktor eine virtuelle Methode aufruft, ist es möglich, dass der Konstruktor für die Instanz, die die Methode aufruft, nicht ausgeführt wurde.|
|[CA2215: Dispose-Methoden müssen die Dispose-Funktion der Basisklasse aufrufen](../code-quality/ca2215-dispose-methods-should-call-base-class-dispose.md)|Wenn ein Typ von einem Typ erbt, der verworfen werden kann, muss von seiner Dispose-Methode die Dispose-Methode des Basistyps aufgerufen werden.|
|[CA2216: Verwerfbare Typen sollten einen Finalizer deklarieren](../code-quality/ca2216-disposable-types-should-declare-finalizer.md)|Ein Typ, der System.IDisposable implementiert und verfügt über Felder, die die Verwendung von nicht verwalteten Ressourcen empfohlen wird einen Finalizer nicht implementiert, wie von Object.Finalize beschrieben.|
|[CA2217: Enumerationen nicht mit FlagsAttribute markieren](../code-quality/ca2217-do-not-mark-enums-with-flagsattribute.md)|Eine extern sichtbare Enumeration wird mit FlagsAttribute gekennzeichnet und weist einen oder mehrere Werte, die keine Potenzen von 2 und keine Kombination von anderen in der Enumeration definierten Werten bilden.|
|[CA2218: GetHashCode beim Überschreiben von Equals überschreiben](../code-quality/ca2218-override-gethashcode-on-overriding-equals.md)|GetHashCode gibt einen Wert auf der Grundlage der aktuellen Instanz zurück, die sich für Hashalgorithmen und Datenstrukturen eignet, z. B. für eine Hashtabelle. Zwei Objekte, die denselben Typ aufweisen und gleich sind, müssen den gleichen Hashcode zurückgeben.|
|[CA2219: Keine Ausnahmen in Ausnahmeklauseln auslösen](../code-quality/ca2219-do-not-raise-exceptions-in-exception-clauses.md)|Wenn eine Ausnahme in einer finally-Klausel oder fault-Klausel ausgelöst wird, wird die aktive Ausnahme von der neuen Ausnahme verdeckt. Wenn eine Ausnahme in einer filter-Klausel ausgelöst wird, fängt die Laufzeit die Ausnahme automatisch ab. Dies ist der ursprüngliche Fehler schwer zu erkennen und zu debuggen.|
|[CA2220: Finalizer sollten Basisklassen-Finalizer aufrufen](../code-quality/ca2220-finalizers-should-call-base-class-finalizer.md)|Der Abschluss muss durch die Vererbungshierarchie weitergegeben werden. Um dies zu garantieren, müssen die Typen die Finalize-Methode ihrer Basisklasse in der eigenen Finalize-Methode aufrufen.|
|[CA2221: Finalizer sollten geschützt sein](../code-quality/ca2221-finalizers-should-be-protected.md)|Finalizer müssen den Familienzugriffsmodifizierer verwenden.|
|[CA2222: Sichtbarkeit für geerbte Member nicht verringern](../code-quality/ca2222-do-not-decrease-inherited-member-visibility.md)|Sie sollten den Zugriffsmodifizierer für geerbte Member nicht ändern. Wenn Sie einen geerbten Member in private ändern, werden Aufrufer nicht am Zugriff auf die Implementierung der Basisklasse der Methode gehindert.|
|[CA2223: Member sollten sich durch mehr als nur den Rückgabetyp unterscheiden](../code-quality/ca2223-members-should-differ-by-more-than-return-type.md)|Die Common Language Runtime lässt die Verwendung von Rückgabetypen zu, mit deren Hilfe zwischen anderweitig identischen Membern unterschieden werden kann. Trotzdem ist diese Funktion nicht in der Common Language Specification (CLS) enthalten und keine gebräuchliche Funktion von .NET-Programmiersprachen.|
|[CA2224: Equals beim Überladen von Gleichheitsoperatoren überschreiben](../code-quality/ca2224-override-equals-on-overloading-operator-equals.md)|Ein öffentlicher Typ implementiert den Gleichheitsoperator, aber überschreibt Object.Equals nicht.|
|[CA2225: Operatorüberladungen weisen benannte Alternativen auf](../code-quality/ca2225-operator-overloads-have-named-alternates.md)|Es wurde eine Operatorüberladung erkannt, und die erwartete benannte Alternativmethode wurde nicht gefunden. Der benannte Alternativmember ermöglicht den Zugriff auf die gleiche Funktionalität wie der Operator, und wird für Entwickler, die in Sprachen programmieren, in denen überladene Operatoren nicht unterstützen bereitgestellt.|
|[CA2226: Operatoren sollten symmetrische Überladungen aufweisen](../code-quality/ca2226-operators-should-have-symmetrical-overloads.md)|Ein Typ implementiert den Gleichheits- oder Ungleichheitsoperator und ohne den entgegengesetzten Operator zu implementieren.|
|[CA2227: Auflistungseigenschaften sollten schreibgeschützt sein](../code-quality/ca2227-collection-properties-should-be-read-only.md)|Eine schreibbare Auflistungseigenschaft ermöglicht es Benutzern, die Auflistung durch eine andere Auflistung zu ersetzen. Eine schreibgeschützte Eigenschaft sorgt dafür, dass die Auflistung nicht mehr ersetzt wird, lässt aber dennoch das Festlegen einzelner Member zu.|
|[CA2228: Nicht freigegebene Ressourcenformate nicht veröffentlichen](../code-quality/ca2228-do-not-ship-unreleased-resource-formats.md)|Ressourcendateien, die mithilfe von Vorabversionen von .NET Framework erstellt wurden, möglicherweise nicht von den unterstützten Versionen von .NET Framework verwendet werden.|
|[CA2229: Serialisierungskonstruktoren implementieren](../code-quality/ca2229-implement-serialization-constructors.md)|Um einen Verstoß gegen diese Regel zu beheben, implementieren Sie den Serialisierungskonstruktor. Definieren Sie den Konstruktor bei einer versiegelten Klasse als privaten Konstruktor. Definieren Sie ihn andernfalls als geschützten Konstruktor.|
|[CA2230: params für Variablenargumente verwenden](../code-quality/ca2230-use-params-for-variable-arguments.md)|Ein öffentlicher oder geschützter Typ enthält eine öffentliche oder geschützte Methode, die statt des params-Schlüsselworts die VarArgs-Aufrufkonvention verwendet.|
|[CA2231: Überladen Sie den Gleichheitsoperator beim Überschreiben von ValueType.Equals](../code-quality/ca2231-overload-operator-equals-on-overriding-valuetype-equals.md)|Ein Werttyp überschreibt Object.Equals, implementiert jedoch nicht den Gleichheitsoperator.|
|[CA2232: Windows Forms-Einstiegspunkte mit STAThread markieren](../code-quality/ca2232-mark-windows-forms-entry-points-with-stathread.md)|STAThreadAttribute gibt an, dass das COM-Threadingmodell für die Anwendung ein Singlethread-Apartment ist. Dieses Attribut muss am Einstiegspunkt jeder Anwendung vorhanden sein, die Windows Forms verwendet. Wird es weggelassen, funktionieren die Windows-Komponenten eventuell nicht richtig.|
|[CA2233: Vorgänge sollten nicht überlaufen](../code-quality/ca2233-operations-should-not-overflow.md)|Arithmetische Operationen sollten nicht ausgeführt werden, ohne zuerst zu überprüfen Operanden an, um sicherzustellen, dass das Ergebnis des Vorgangs nicht außerhalb des Bereichs möglicher Werte für die beteiligten Datentypen liegt.|
|[CA2234: Übergeben Sie System.Uri-Objekte anstelle von Zeichenfolgen](../code-quality/ca2234-pass-system-uri-objects-instead-of-strings.md)|Eine Methode wird aufgerufen, die über einen Zeichenfolgenparameter verfügt, dessen Name "uri", "URI", "urn", "URN", "url" oder "URL" enthält.  Der deklarierende Typ der Methode enthält eine entsprechende Methodenüberladung, die über einen System.Uri-Parameter verfügt.|
|[CA2235: Alle nicht serialisierbaren Felder markieren](../code-quality/ca2235-mark-all-non-serializable-fields.md)|Ein Instanzenfeld eines Typs, der nicht serialisierbar ist, ist in einem serialisierbaren Typ deklariert.|
|[CA2236: Basisklassenmethoden auf ISerializable-Typen aufrufen](../code-quality/ca2236-call-base-class-methods-on-iserializable-types.md)|Um einen Verstoß gegen diese Regel zu beheben, rufen Sie die GetObjectData-Methode oder den Serialisierungskonstruktor des Basistyps in der Methode oder im Konstruktor des entsprechenden abgeleiteten Typs auf.|
|[CA2237: Markieren von ISerializable-Typen mit SerializableAttribute](../code-quality/ca2237-mark-iserializable-types-with-serializableattribute.md)|Um von der common Language Runtime als serialisierbar erkannt werden, müssen Typen mit SerializableAttribute-Attribut markiert werden, auch wenn die Implementierung der ISerializable-Schnittstelle eine benutzerdefinierte Serialisierungsroutine verwendet.|
|[CA2238: Serialisierungsmethoden korrekt implementieren](../code-quality/ca2238-implement-serialization-methods-correctly.md)|Eine Methode, die ein Serialisierungsereignis behandelt, verfügt nicht über die richtige Signatur, den richtigen Rückgabetyp oder die richtige Sichtbarkeit.|
|[CA2239: Deserialisierungsmethoden für optionale Felder angeben](../code-quality/ca2239-provide-deserialization-methods-for-optional-fields.md)|Ein Typ verfügt über ein Feld, das mit dem System.Runtime.Serialization.OptionalFieldAttribute-Attribut markiert ist, und der Typ stellt keine Methoden Deserialisierungsereignisbehandlung bereit.|
|[CA2240: ISerializable ordnungsgemäß implementieren](../code-quality/ca2240-implement-iserializable-correctly.md)|Um einen Verstoß gegen diese Regel zu beheben, stellen Sie die GetObjectData-Methode sichtbar und überschreibbar, und stellen Sie sicher, dass alle Instanzenfelder in den Serialisierungsprozess einbezogen oder explizit mit dem NonSerializedAttribute-Attribut markiert.|
|[CA2241: Geeignete Argumente für Formatierungsmethoden angeben](../code-quality/ca2241-provide-correct-arguments-to-formatting-methods.md)|Das an System.String.Format übergebene Formatierungsargument enthält keine Formatelemente, die den einzelnen Objektargumenten (oder umgekehrt) entspricht.|
|[CA2242: Ordnungsgemäß auf NaN testen](../code-quality/ca2242-test-for-nan-correctly.md)|Mit diesem Ausdruck testen Sie einen Wert auf Single.Nan oder Double.Nan. Testen Sie den Wert mithilfe von Single.IsNan(Single) oder Double.IsNan(Double).|
|[CA2243: Attribute-Zeichenfolgenliterale müssen stets richtig analysiert werden](../code-quality/ca2243-attribute-string-literals-should-parse-correctly.md)|Ein Attribut Zeichenfolgenliteral-Parameter wird für eine URL, eine GUID oder eine Version nicht ordnungsgemäß analysiert.|