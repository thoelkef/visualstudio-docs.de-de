---
title: C26112 | Microsoft-Dokumentation
ms.custom: ''
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.reviewer: ''
ms.suite: ''
ms.technology:
- vs-devops-test
ms.tgt_pltfrm: ''
ms.topic: article
f1_keywords:
- C26112
helpviewer_keywords:
- C26112
ms.assetid: 926de738-b9b0-43d7-9137-ab2daa44ad4d
caps.latest.revision: 9
author: corob-msft
ms.author: gewarren
manager: ghogen
ms.openlocfilehash: 477ab1a55350f98c200c78a4591ef66000ca0964
ms.sourcegitcommit: 9ceaf69568d61023868ced59108ae4dd46f720ab
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 10/12/2018
ms.locfileid: "49272511"
---
# <a name="c26112"></a>C26112
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Warnung C26112: aufrechterhalten Aufrufer kann nicht sperren vor dem Aufruf \<Func >.  
  
 Die Anmerkung `_Requires_no_locks_held_` erzwingt eine Voraussetzung, dass der Aufrufer nicht aufrechterhalten von Sperren muss, während sie die Funktion aufruft. Warnung C26112 wird ausgegeben, wenn eine Funktion fehlschlägt, alle Sperren freizugeben, bevor sie eine andere Funktion aufruft.  
  
## <a name="example"></a>Beispiel  
 Im folgende Beispiel wird die Warnung C26112 generiert, da die `_Requires_no_locks_held_` Vorbedingung verletzt wird, durch den Aufruf von `NoLocksAllowed` im gesperrten Abschnitt.  
  
```  
  
typedef struct _DATA   
{  
    CRITICAL_SECTION cs;  
} DATA;  
  
_Requires_no_locks_held_   
  
void NoLocksAllowed(DATA* p)  
{  
     // Lock sensitive operations here  
}  
  
void LocksHeldFunction(DATA* p)   
{   
    EnterCriticalSection(&p->cs);   
    NoLocksAllowed(p); // Warning C26112  
    LeaveCriticalSection(&p->cs);  
}  
  
```



